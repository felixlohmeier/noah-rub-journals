<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/  http://www.openarchives.org/OAI/2.0/oai_dc.xsd"><id>8793</id>
	<dc:title xml:lang="en-US">Revisiting the functional bootstrap in TFHE</dc:title>
	<dc:creator>Guimarães, Antonio</dc:creator>
	<dc:creator>Borin, Edson</dc:creator>
	<dc:creator>Aranha, Diego F. </dc:creator>
	<dc:subject xml:lang="en-US">Functional Bootstrap</dc:subject>
	<dc:subject xml:lang="en-US">TFHE</dc:subject>
	<dc:subject xml:lang="en-US">Lookup Table</dc:subject>
	<dc:subject xml:lang="en-US">Homomorphic Encryption</dc:subject>
	<dc:description xml:lang="en-US">The FHEW cryptosystem introduced the idea that an arbitrary function can be evaluated within the bootstrap procedure as a table lookup. The faster bootstraps of TFHE strengthened this approach, which was later named Functional Bootstrap (Boura et al., CSCML’19). From then on, little effort has been made towards defining efficient ways of using it to implement functions with high precision. In this paper, we introduce two methods to combine multiple functional bootstraps to accelerate the evaluation of reasonably large look-up tables and highly precise functions. We thoroughly analyze and experimentally validate the error propagation in both methods, as well as in the functional bootstrap itself. We leverage the multi-value bootstrap of Carpov et al. (CT-RSA’19) to accelerate (single) lookup table evaluation, and we improve it by lowering the complexity of its error variance growth from quadratic to linear in the value of the output base. Compared to previous literature using TFHE’s functional bootstrap, our methods are up to 2.49 times faster than the lookup table evaluation of Carpov et al. (CT-RSA’19) and up to 3.19 times faster than the 32-bit integer comparison of Bourse et al. (CT-RSA’20). Compared to works using logic gates, we achieved speedups of up to 6.98, 8.74, and 3.55 times over 8-bit implementations of the functions ReLU, Addition, and Maximum, respectively.</dc:description>
	<dc:publisher xml:lang="en-US">Ruhr-Universität Bochum</dc:publisher>
	<dc:date>2021-02-23</dc:date>
	<dc:type>info:eu-repo/semantics/article</dc:type>
	<dc:type>info:eu-repo/semantics/publishedVersion</dc:type>
	<dc:format>application/pdf</dc:format>
	<dc:identifier>https://tches.iacr.org/index.php/TCHES/article/view/8793</dc:identifier>
	<dc:identifier>10.46586/tches.v2021.i2.229-253</dc:identifier>
	<dc:source xml:lang="en-US">IACR Transactions on Cryptographic Hardware and Embedded Systems; Volume 2021, Issue 2; 229-253</dc:source>
	<dc:source>2569-2925</dc:source>
	<dc:language>eng</dc:language>
	<dc:relation>https://tches.iacr.org/index.php/TCHES/article/view/8793/8393</dc:relation>
	<dc:rights xml:lang="en-US">Copyright (c) 2021 Antonio Guimarães, Edson Borin, Diego F. Aranha</dc:rights>
	<dc:rights xml:lang="en-US">http://creativecommons.org/licenses/by/4.0/</dc:rights>
</oai_dc:dc>